<?php

namespace Composer\Autoload;

use Composer\Config;
use Composer\Package\PackageInterface;
use Composer\Util\Filesystem;

class AutoloadGeneratorHelper
{
    private $filesystem;
    private $basePath;
    private $vendorPath;
    private $targetPath;
    private $vendorPathCode52;
    private $appBaseDirCode;
    private $vendorPathToTargetDirCode;

    public function __construct($vendorDir, $targetDir)
    {
        $this->filesystem = new Filesystem();
        $this->filesystem->ensureDirectoryExists($vendorDir);
        $this->basePath = $this->filesystem->normalizePath(getcwd());
        $this->vendorPath = $this->filesystem->normalizePath(realpath($vendorDir));
        $this->targetPath = $this->vendorPath.'/'.$targetDir;
        $this->filesystem->ensureDirectoryExists($this->targetPath);

        $this->vendorPathCode = $this->filesystem->findShortestPathCode(realpath($this->targetPath), $this->vendorPath, true);
        $this->vendorPathCode52 = str_replace('__DIR__', 'dirname(__FILE__)', $this->vendorPathCode);
        $this->vendorPathToTargetDirCode = $this->filesystem->findShortestPathCode($this->vendorPath, realpath($this->targetPath), true);

        $appBaseDirCode = $this->filesystem->findShortestPathCode($this->vendorPath, $this->basePath, true);
        $this->appBaseDirCode = str_replace('__DIR__', '$vendorDir', $appBaseDirCode);
    }

    public function getVendorPath()
    {
        return $this->vendorPath;
    }

    public function dumpNamespacesFile($psr0)
    {
        $namespacesCode = '';
        foreach ($psr0 as $namespace => $paths) {
            $exportedPaths = array();
            foreach ($paths as $path) {
                $exportedPaths[] = $this->getPathCode($path);
            }
            $exportedPrefix = var_export($namespace, true);
            $namespacesCode .= "    $exportedPrefix => ";
            $namespacesCode .= "array(".implode(', ', $exportedPaths)."),\n";
        }
        $php = <<<EOF
<?php

// autoload_namespaces.php generated by Composer

\$vendorDir = {$this->vendorPathCode52};
\$baseDir = {$this->appBaseDirCode};

return array(
$namespacesCode);

EOF;
        file_put_contents($this->targetPath.'/autoload_namespaces.php', $php);

        return <<<'PSR0'

        $map = require __DIR__ . '/autoload_namespaces.php';
        foreach ($map as $namespace => $path) {
            $loader->set($namespace, $path);
        }

PSR0;
    }

    public function buildClassMapFromPsr0Scan(array $psr0)
    {
        // flatten array
        $classMap = array();
        foreach ($psr0 as $namespace => $paths) {
            foreach ($paths as $dir) {
                $dir = $this->filesystem->normalizePath($this->filesystem->isAbsolutePath($dir) ? $dir : $this->basePath.'/'.$dir);
                if (!is_dir($dir)) {
                    continue;
                }
                $whitelist = sprintf(
                    '{%s/%s.+(?<!(?<!/)Test\.php)$}',
                    preg_quote($dir),
                    strpos($namespace, '_') === false ? preg_quote(strtr($namespace, '\\', '/')) : ''
                );
                foreach (ClassMapGenerator::createMap($dir, $whitelist) as $class => $path) {
                    if ('' === $namespace || 0 === strpos($class, $namespace)) {
                        if (!isset($classMap[$class])) {
                            $classMap[$class] = $path;
                        }
                    }
                }
            }
        }

        return $classMap;
    }

    public function dumpClassmapFile(array $classMap)
    {
        $classmapCode = '';
        foreach ($classMap as $class => $path) {
            $pathCode = $this->getPathCode($path);
            $classmapCode .= '    '.var_export($class, true).' => '.$pathCode.",\n";
        }
        $php = <<<EOF
<?php

// autoload_classmap.php generated by Composer

\$vendorDir = $this->vendorPathCode52;
\$baseDir = $this->appBaseDirCode;

return array(
$classmapCode);

EOF;
        file_put_contents($this->targetPath.'/autoload_classmap.php', $php);

        return <<<'CLASSMAP'

        $classMap = require __DIR__ . '/autoload_classmap.php';
        if ($classMap) {
            $loader->addClassMap($classMap);
        }

CLASSMAP;
    }

    public function dumpIncludePathsFile(array $packageMap)
    {
        $includePaths = array();

        foreach ($packageMap as $item) {
            /**
             * @var PackageInterface $package
             */
            list($package, $installPath) = $item;

            if (null !== $package->getTargetDir() && strlen($package->getTargetDir()) > 0) {
                $installPath = substr($installPath, 0, -strlen('/'.$package->getTargetDir()));
            }

            foreach ($package->getIncludePaths() as $includePath) {
                $includePath = trim($includePath, '/');
                $includePaths[] = empty($installPath) ? $includePath : $installPath.'/'.$includePath;
            }
        }

        if (!$includePaths) {
            return '';
        }

        $includePathsCode = '';
        foreach ($includePaths as $path) {
            $includePathsCode .= "    " . $this->getPathCode($path) . ",\n";
        }

        $php = <<<EOF
<?php

// include_paths.php generated by Composer

\$vendorDir = $this->vendorPathCode52;
\$baseDir = $this->appBaseDirCode;

return array(
$includePathsCode);

EOF;
        file_put_contents($this->targetPath.'/include_paths.php', $php);

        return <<<'INCLUDE_PATH'

        $includePaths = require __DIR__ . '/include_paths.php';
        array_push($includePaths, get_include_path());
        set_include_path(join(PATH_SEPARATOR, $includePaths));

INCLUDE_PATH;
    }

    public function dumpIncludeFilesFile(array $files)
    {
        $filesCode = '';
        $files = new \RecursiveIteratorIterator(new \RecursiveArrayIterator($files));
        foreach ($files as $functionFile) {
            $filesCode .= '    '.$this->getPathCode($functionFile).",\n";
        }

        if (!$filesCode) {
            return '';
        }

        $php = <<<EOF
<?php

// autoload_files.php generated by Composer

\$vendorDir = $this->vendorPathCode52;
\$baseDir = $this->appBaseDirCode;

return array(
$filesCode);
EOF;
        file_put_contents($this->targetPath.'/autoload_files.php', $php);

        return <<<INCLUDE_FILES

        foreach (require __DIR__ . '/autoload_files.php' as \$file) {
            require \$file;
        }

INCLUDE_FILES;
    }

    public function dumpAutoloadFile($suffix)
    {
        $php = <<<AUTOLOAD
<?php

// autoload.php generated by Composer

require_once $this->vendorPathToTargetDirCode . '/autoload_real.php';

return ComposerAutoloaderInit$suffix::getLoader();

AUTOLOAD;
        file_put_contents($this->vendorPath.'/autoload.php', $php);

        return true;
    }

    public function dumpAutoloadRealFile($loaderSetupCode, $suffix, $targetDirLoader)
    {
        // TODO the class ComposerAutoloaderInit should be revert to a closure
        // when APC has been fixed:
        // - https://github.com/composer/composer/issues/959
        // - https://bugs.php.net/bug.php?id=52144
        // - https://bugs.php.net/bug.php?id=61576
        // - https://bugs.php.net/bug.php?id=59298

        $file = <<<EOF
<?php

// autoload_real.php generated by Composer

class ComposerAutoloaderInit$suffix
{
    private static \$loader;

    public static function loadClassLoader(\$class)
    {
        if ('Composer\\Autoload\\ClassLoader' === \$class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    public static function getLoader()
    {
        if (null !== self::\$loader) {
            return self::\$loader;
        }

        spl_autoload_register(array('ComposerAutoloaderInit$suffix', 'loadClassLoader'), true, true);
        self::\$loader = \$loader = new \\Composer\\Autoload\\ClassLoader();
        spl_autoload_unregister(array('ComposerAutoloaderInit$suffix', 'loadClassLoader'));

        \$vendorDir = $this->vendorPathCode;
        \$baseDir = $this->appBaseDirCode;
$loaderSetupCode
        return \$loader;
    }
$targetDirLoader}

EOF;
        file_put_contents($this->targetPath.'/autoload_real.php', $file);
        return true;
    }

    public function getTargetDirLoaderMethod($mainPackageTargetDir, $psr0)
    {
        $levels = count(explode('/', $this->filesystem->normalizePath($mainPackageTargetDir)));
        $prefixes = implode(', ', array_map(function ($prefix) {
            return var_export($prefix, true);
        }, array_keys($psr0)));

        $baseDirFromTargetDirCode = $this->filesystem->findShortestPathCode($this->targetPath, $this->basePath, true);

        return <<<EOF

    public static function autoload(\$class)
    {
        \$dir = $baseDirFromTargetDirCode . '/';
        \$prefixes = array($prefixes);
        foreach (\$prefixes as \$prefix) {
            if (0 !== strpos(\$class, \$prefix)) {
                continue;
            }
            \$path = \$dir . implode('/', array_slice(explode('\\\\', \$class), $levels)).'.php';
            if (!\$path = stream_resolve_include_path(\$path)) {
                return false;
            }
            require \$path;

            return true;
        }
    }

EOF;
    }

    protected function getPathCode($path)
    {
        if (!$this->filesystem->isAbsolutePath($path)) {
            $path = $this->basePath . '/' . $path;
        }
        $path = $this->filesystem->normalizePath($path);

        $baseDir = '';
        if (strpos($path, $this->vendorPath) === 0) {
            $path = substr($path, strlen($this->vendorPath));
            $baseDir = '$vendorDir . ';
        } else {
            $path = $this->filesystem->normalizePath($this->filesystem->findShortestPath($this->basePath, $path, true));
            if (!$this->filesystem->isAbsolutePath($path)) {
                $baseDir = '$baseDir . ';
                $path = '/' . $path;
            }
        }

        if (preg_match('/\.phar$/', $path)) {
            $baseDir = "'phar://' . " . $baseDir;
        }

        return $baseDir.var_export($path, true);
    }
}