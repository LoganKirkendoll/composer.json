<?php

namespace Composer\Autoload\Generator;

class AutoloadGeneratorHelper
{
    /**
     * @param AutoloadGenerationTask $task
     */
    public function dumpAutoloadFile(AutoloadGenerationTask $task)
    {
        $php = <<<AUTOLOAD
<?php

// autoload.php generated by Composer

require_once {$task->vendorPathToTargetDirCode} . '/autoload_real.php';

return ComposerAutoloaderInit{$task->suffix}::getLoader();

AUTOLOAD;
        file_put_contents($task->vendorPath.'/autoload.php', $php);
    }

    /**
     * @param AutoloadGenerationTask $task
     * @param string $loaderSetupCode
     * @param string $extraMethodsCode
     * @return bool
     */
    public function dumpAutoloadRealFile($task, $loaderSetupCode, $extraMethodsCode)
    {
        // TODO the class ComposerAutoloaderInit should be revert to a closure
        // when APC has been fixed:
        // - https://github.com/composer/composer/issues/959
        // - https://bugs.php.net/bug.php?id=52144
        // - https://bugs.php.net/bug.php?id=61576
        // - https://bugs.php.net/bug.php?id=59298

        $file = <<<EOF
<?php

// autoload_real.php generated by Composer

class ComposerAutoloaderInit{$task->suffix}
{
    private static \$loader;

    public static function loadClassLoader(\$class)
    {
        if ('Composer\\Autoload\\ClassLoader' === \$class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    public static function getLoader()
    {
        if (null !== self::\$loader) {
            return self::\$loader;
        }

        spl_autoload_register(array('ComposerAutoloaderInit{$task->suffix}', 'loadClassLoader'), true, true);
        self::\$loader = \$loader = new \\Composer\\Autoload\\ClassLoader();
        spl_autoload_unregister(array('ComposerAutoloaderInit{$task->suffix}', 'loadClassLoader'));

        \$vendorDir = $task->vendorPathCode;
        \$baseDir = $task->appBaseDirCode;
$loaderSetupCode
        return \$loader;
    }
$extraMethodsCode}

EOF;
        file_put_contents($task->targetPath.'/autoload_real.php', $file);
    }

    /**
     * @param string $targetPath
     */
    public function dumpClassLoader($targetPath)
    {
        // Use stream_copy_to_stream instead of copy,
        // to work around https://bugs.php.net/bug.php?id=64634.
        $sourceLoader = fopen(dirname(__DIR__).'/ClassLoader.php', 'r');
        $targetLoader = fopen($targetPath.'/ClassLoader.php', 'w+');
        stream_copy_to_stream($sourceLoader, $targetLoader);
        fclose($sourceLoader);
        fclose($targetLoader);
        unset($sourceLoader, $targetLoader);
    }

    /**
     * Generates a PHP file returning an array.
     *
     * @param AutoloadGenerationTask $task
     * @param string $filename
     *   File name without the directory.
     * @param string $itemsCode
     *   PHP code that expresses the array values.
     * @param string $prepend
     *   String to append at the end of the file.
     *   This is a temporary solution to avoid tests from breaking, because some of the generated files are expected to
     *   have an additional linebreak in the end.
     */
    public function dumpArrayFile(AutoloadGenerationTask $task, $filename, $itemsCode, $prepend = "\n")
    {
        $php = <<<EOF
<?php

// $filename generated by Composer

\$vendorDir = {$task->vendorPathCode52};
\$baseDir = {$task->appBaseDirCode};

return array(
$itemsCode);
EOF;
        file_put_contents($task->targetPath . '/' . $filename, $php . $prepend);
    }

    /**
     * @param AutoloadGenerationTask $task
     * @param string $path
     * @return string
     */
    public function getPathCode(AutoloadGenerationTask $task, $path)
    {
        if (!$task->filesystem->isAbsolutePath($path)) {
            $path = $task->basePath . '/' . $path;
        }
        $path = $task->filesystem->normalizePath($path);

        $baseDir = '';
        if (strpos($path, $task->vendorPath) === 0) {
            $path = substr($path, strlen($task->vendorPath));
            $baseDir = '$vendorDir . ';
        } else {
            $path = $task->filesystem->normalizePath($task->filesystem->findShortestPath($task->basePath, $path, true));
            if (!$task->filesystem->isAbsolutePath($path)) {
                $baseDir = '$baseDir . ';
                $path = '/' . $path;
            }
        }

        if (preg_match('/\.phar$/', $path)) {
            $baseDir = "'phar://' . " . $baseDir;
        }

        return $baseDir.var_export($path, true);
    }
}